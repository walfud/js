---
title: 对称密码与公钥密码
date: 2016/9/30
---

# <a name="symmetric">对称密码</a> (也称: 共享密码)
![](/images/cryptology/symmetric.png)

简单来说, 任何一端生成一个密码, 发送给另一端. 此后两端通信使用都是用该密码进行加密解密.

### 存在的问题
如图中 Sniffer 所做, 任何 Client 和 Server 间的数据都可以被窃取.

### 常见算法
* [DES](https://en.wikipedia.org/wiki/Triple_DES)
* [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)


---


# 公钥密码
公钥密码都是基于某个数学难题, 从而实现如下功能:
* 某个算法可以生成两个数据, 一个叫做私钥, 一个叫做公钥
* 私钥
  - 可加密任何数据
  - 可解密被公钥加密的数据
  - 用于生成公钥
  - 只能自己保留
* 公钥
  - 可加密任何数据
  - 可解密被私钥加密的数据
  - 可以公开给别人

![](/images/cryptology/public_key.png)

上图中,

1. 客户端 -> 服务端: 传递 _公钥_
  1. 客户端使用某种算法生成了一对秘钥(_公钥_ 和 _私钥_), 并将 _公钥_ 发送给了服务端
  2. 服务端收到了 _公钥_. 同时, Sniffer 也窃听到了公钥  
2. 服务端 -> 客户端: 传递 _对称密码_
  1. 服务端生成了一个 _对称密码_, 然后使用刚收到的公钥加密了这个 _对称密码_, 并发送给了客户端
  2. 客户端收到了这段密文. 使用自己的 _私钥_ 解密了密文, 获得了从服务端传来的 _对称密码_
  3. 但此时, Sniffer 虽然也窃取到了这段密文, 但是 Sniffer 没有 _私钥_, 因此无法解密这段内容  
3. 客户端 -> 服务端: 使用 _对称密码_ 通信
  1. 客户端使用刚解密得到的 _对称密码_ 对数据加密, 然后发送给客户端
  2. 服务端又收到了密文, 并使用之前生成的 _对称密码_ 解密数据, 得到了原文
  3. 此时, Sniffer 依然能够窃取到密文, 但是他没有 _对称密码_, 所以还是无法解密
4. 客户端 -> 服务端: 使用 _对称密码_ 通信
  1. 客户端和服务端继续使用 _对称密码_ 进行通信
  2. Sniffer 即便窃取到密文, 也无法解密

### 解决的问题
解决了 _[对称密码](#symmetric)_ 中 **秘钥配送问题**. 即: 客户端成功的将密码安全的发送给服务端, 而不被窃听者获取到原文.

### 常见算法
* RSA
